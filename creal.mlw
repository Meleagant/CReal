use mach.int.Int
use real.RealInfix
use int.Power
use int.Abs
use int.EuclideanDivision as ED
use real.Square
use real.FromInt
use real.Truncate
use ref.Ref

(* ___        _          _                     
  |_ _|      / \   __  _(_) ___  _ __ ___  ___ 
   | |      / _ \  \ \/ / |/ _ \| '_ ` _ \/ __|
   | | _   / ___ \  >  <| | (_) | | | | | \__ \
  |___(_) /_/   \_\/_/\_\_|\___/|_| |_| |_|___/
                                             
*)

use real.ExpLog

axiom log_incr: 
  forall x y: real. 0.0 <. x <. y -> (log x) <. (log y)

(*
   ___ ___     _____                 _   _                 
  |_ _|_ _|   |  ___|   _ _ __   ___| |_(_) ___  _ __  ___ 
   | | | |    | |_ | | | | '_ \ / __| __| |/ _ \| '_ \/ __|
   | | | | _  |  _|| |_| | | | | (__| |_| | (_) | | | \__ \
  |___|___(_) |_|   \__,_|_| |_|\___|\__|_|\___/|_| |_|___/              
*)   

(*---------------------------------------------
    Question 1
  ---------------------------------------------*)


let power2 (l:int) : int
requires { 0 <= l }
ensures { result = power 2 l }
ensures { result > 0 }
=
  let x = ref l in
  let res = ref 1 in
  while ( !x > 0) do
    variant { !x }
    invariant { !x >= 0 }
    invariant { !res * power 2 !x = power 2 l }
    invariant { !res > 0 }
    x := !x - 1;
    res := 2 * !res
  done;
  !res

(*---------------------------------------------
    Question 2
  ---------------------------------------------*)

let shift_left (z: int) (l:int) : int
requires { 0 <= l }
ensures { result = z * (power 2 l) }
= 
  z * power2 l

(*---------------------------------------------
    Question 3
  ---------------------------------------------*)

let ediv_mod (x:int) (y:int) : (int, int)
requires { 0 < y }
ensures { let d,r = result in
   d = ED.div x y /\ r = ED.mod x y }
=
  let r = ref x in
  let d = ref 0 in
  if !r >= 0 then
  begin
    while (!r >= y) do
      invariant { x = !d * y + !r }
      invariant { !r >= 0}
      variant { (abs !r) - y }
      r := !r - y;
      d := !d + 1
    done;
    !d, !r
  end
  else
  begin
    while (!r < 0) do
      invariant { x = !d * y + !r }
      invariant { !r < y}
      variant { - !r }
      r := !r + y;
      d := !d - 1
    done;
    assert { 0 <= !r < y };
    !d, !r
  end

(*---------------------------------------------
    Question 4
  ---------------------------------------------*)

let shift_right (z: int) (l:int) : int
requires { 0 <= l }
ensures { result = ED.div z (power 2 l) }
= 
  let p2l = power2 l in
  assert { p2l > 0 };
  let d, _ = ediv_mod z p2l in
    d