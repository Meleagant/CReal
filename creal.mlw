use mach.int.Int
use real.RealInfix
use int.Power
use int.Abs
use int.EuclideanDivision as ED
use real.Square
use real.FromInt
use real.Truncate
use ref.Ref

(* ___        _          _                     
  |_ _|      / \   __  _(_) ___  _ __ ___  ___ 
   | |      / _ \  \ \/ / |/ _ \| '_ ` _ \/ __|
   | | _   / ___ \  >  <| | (_) | | | | | \__ \
  |___(_) /_/   \_\/_/\_\_|\___/|_| |_| |_|___/
                                             
*)

use real.ExpLog

axiom log_incr: 
  forall x y: real. 0.0 <. x <. y -> (log x) <. (log y)

(*
   ___ ___     _____                 _   _                 
  |_ _|_ _|   |  ___|   _ _ __   ___| |_(_) ___  _ __  ___ 
   | | | |    | |_ | | | | '_ \ / __| __| |/ _ \| '_ \/ __|
   | | | | _  |  _|| |_| | | | | (__| |_| | (_) | | | \__ \
  |___|___(_) |_|   \__,_|_| |_|\___|\__|_|\___/|_| |_|___/              
*)   

(*---------------------------------------------
    Question 1
  ---------------------------------------------*)


let power2 (l:int) : int
requires { 0 <= l }
ensures { result = power 2 l }
ensures { result > 0 }
=
  let x = ref l in
  let res = ref 1 in
  while ( !x > 0) do
    variant { !x }
    invariant { !x >= 0 }
    invariant { !res * power 2 !x = power 2 l }
    invariant { !res > 0 }
    x := !x - 1;
    res := 2 * !res
  done;
  !res

(*---------------------------------------------
    Question 2
  ---------------------------------------------*)

let shift_left (z: int) (l:int) : int
requires { 0 <= l }
ensures { result = z * (power 2 l) }
= 
  z * power2 l

(*---------------------------------------------
    Question 3
  ---------------------------------------------*)

let ediv_mod (x:int) (y:int) : (int, int)
requires { 0 < y }
ensures { let d,r = result in
   d = ED.div x y /\ r = ED.mod x y }
=
  let r = ref x in
  let d = ref 0 in
  if !r >= 0 then
  begin
    while (!r >= y) do
      invariant { x = !d * y + !r }
      invariant { !r >= 0}
      variant { (abs !r) - y }
      r := !r - y;
      d := !d + 1
    done;
    !d, !r
  end
  else
  begin
    while (!r < 0) do
      invariant { x = !d * y + !r }
      invariant { !r < y}
      variant { - !r }
      r := !r + y;
      d := !d - 1
    done;
    assert { 0 <= !r < y };
    !d, !r
  end

(*---------------------------------------------
    Question 4
  ---------------------------------------------*)

let shift_right (z: int) (l:int) : int
requires { 0 <= l }
ensures { result = ED.div z (power 2 l) }
= 
  let p2l = power2 l in
  assert { p2l > 0 };
  let d, _ = ediv_mod z p2l in
    d

(*---------------------------------------------
    Question 5
  ---------------------------------------------*)

let function isqrt (n: int) : int
  requires {0 <= n}
  ensures { result = floor (sqrt (from_int n)) }
=
  let res = ref 0 in
  while (!res + 1) * (!res + 1) <= n do
    invariant { !res >= 0 }
    invariant { !res * !res <= n }
    variant { n - (!res * !res) }
    res := !res + 1;
  done;
  assert { sqrt (from_int (!res * !res))
            <=. sqrt (from_int n)
            <. sqrt (from_int ((!res +1) * (!res+1))) };
  !res
      
let lemma euclid_uniq (x y q : int) : unit
  requires { y > 0 }
  requires { q * y <= x < q *y + y }
  ensures { ED.div x y = q }
= () 

(* ___ ___ ___   _   _             _     _                       
  |_ _|_ _|_ _| | \ | | ___  _ __ | |   (_)_ __   ___  __ _ _ __ 
   | | | | | |  |  \| |/ _ \| '_ \| |   | | '_ \ / _ \/ _` | '__|
   | | | | | | _| |\  | (_) | | | | |___| | | | |  __/ (_| | |   
  |___|___|___(_)_| \_|\___/|_| |_|_____|_|_| |_|\___|\__,_|_|   
*)

use real.PowerReal

let ghost function _B (n: int) : real = pow 4.0 (from_int n)

(*---------------------------------------------
    Question 6
  ---------------------------------------------*)
let lemma positiv (n: int) : unit 
  ensures { _B n >=. 0.0 }
= ()

(*---------------------------------------------
    Question 7
  ---------------------------------------------*)
let lemma morphisme (n m: int): unit 
  ensures { (_B n) *. (_B m) = _B (n+m) }
= ()

(*---------------------------------------------
    Question 8
  ---------------------------------------------*)
let lemma inv (n: int) : unit
  ensures { (_B n) *. (_B (-n)) = 1.0 }
= ()
 
(*---------------------------------------------
    Question 9
  ---------------------------------------------*)

let lemma question9 (a: real) (n: int) : unit
  requires { 0.0 <=. a }
  ensures {sqrt (a *. _B (2*n)) = sqrt a *. _B n }
= 
  assert { sqrt (_B (2*n)) = _B n };
  ()
  
(*---------------------------------------------
    Question 10
  ---------------------------------------------*)
let lemma b_y_power_4_y_pos (y: int) : unit
  requires { 0 <= y }
  ensures { _B y = from_int (power 4 y) }
= ()

(*---------------------------------------------
    Question 11
  ---------------------------------------------*)
let lemma b_y_power_4_y_neg (y: int) : unit
  requires { y < 0 }
  ensures { inv (_B y) = from_int (power 4 (-y)) }
=
  assert { inv (_B y) = _B (-y) }; 
  ()
(*---------------------------------------------
    Question 12
  ---------------------------------------------*)
let lemma power_2_2_is_4 (y: int) : unit
  requires { 0 <= y }
  ensures { power 2 (2 * y) = power 4 y }
= ()

(*__     _____   ____                            _   ____            _ 
  \ \   / /_ _| / ___|___  _ __ ___  _ __  _   _| |_|  _ \ ___  __ _| |
   \ \ / / | | | |   / _ \| '_ ` _ \| '_ \| | | | __| |_) / _ \/ _` | |
    \ V /  | | | |__| (_) | | | | | | |_) | |_| | |_|  _ <  __/ (_| | |
     \_/  |___(_)____\___/|_| |_| |_| .__/ \__,_|\__|_| \_\___|\__,_|_|
                                    |_|
*)

(*---------------------------------------------
    Question 13
  ---------------------------------------------*)
predicate framing (x:real) (p:int) (n:int) =
  (from_int p -. 1.) *. (_B (-n)) <. x <. (from_int p +. 1.) *. (_B (-n))



(* _____     ___      _       _     _ _ _   _             
  |_ _\ \   / / |    / \   __| | __| (_) |_(_) ___  _ __  
   | | \ \ / /| |   / _ \ / _` |/ _` | | __| |/ _ \| '_ \ 
   | |  \ V /_| |_ / ___ \ (_| | (_| | | |_| | (_) | | | |
  |___|  \_/(_)_(_)_/   \_\__,_|\__,_|_|\__|_|\___/|_| |_|
*)


(*---------------------------------------------
    Question 14
  ---------------------------------------------*)

let round_z_over_4 (z: int)
  ensures { ((from_int z) -. 2.) *. (_B (-1)) 
            <. from_int result
            <=. ((from_int z) +. 2.) *. (_B (-1)) }
=
  let ghost z' = z - 2 in
  (* Prove of left *)
  assert { from_int (ED.div (z + 2) 4) <=. (from_int (z+2)) /. 4.  
      by ((from_int z) +. 2.) *. (_B (-1)) = ((from_int z) +. 2.) /. 4. } ;
  (* Prove of right *)
  assert { ((from_int z) -. 2.) /. 4. <. from_int (ED.div (z + 2) 4) 
    by ED.div (z - 2) 4 < ED.div (z + 2) 4
    so from_int z' /. 4. <. from_int (ED.div z' 4 + 1) };
  shift_right (z + 2) 2 


let compute_round (n: int) (ghost z: real) (zp: int) 
  requires {  ((from_int zp) -. 2.) *. (_B (-(n+1))) 
            <. z
            <=. ((from_int zp) +. 2.) *. (_B (-(n+1))) }
  ensures { framing z result n }
=
  let res = round_z_over_4 zp in (* res = (zp + 2)//4 *)
  (* Prove left *)
  (*
  let ghost z' = zp - 2 in
  *)
  assert { (from_int res -. 1.) <=. ((from_int zp) -. 2.) /. 4.
    by from_int res -. 1. 
    <=. ((from_int zp) +. 2.) *. _B (-1) -. 1.
    = ((from_int zp) +. 2.) /. 4. -. 1.
    = ((from_int zp) -. 2.) /. 4. };
  assert { _B (-(n+1)) = _B (-n) *. _B (-1) = _B (-n) /. 4. };
  assert { (from_int res -. 1.) *. (_B (-n)) 
          <=. (((from_int zp) -. 2.) /. 4.)  *. (_B (-(n)))};
  (* Prove right *)
  assert { (from_int zp +. 2. ) /. 4. *. (_B (-n)) <. (from_int res +. 1.) *. (_B (-n)) };
  res

let compute_add (n: int) (ghost x: real) (xp: int) (ghost y: real) (yp: int)
  requires { framing x xp (n+1) }
  requires { framing y yp (n+1) }
  ensures { framing (x+.y) result n }
=
  (*
  assert { ((from_int xp) -. 1.) *. (_B (-(n+1))) <. x };
  assert { ((from_int yp) -. 1.) *. (_B (-(n+1))) <. y };
  
  assert { ((from_int xp) -. 1.) *. (_B (-(n+1))) +. ((from_int yp) -. 1.) *. (_B (-(n+1)))
    = ((from_int (xp + yp)) -. 2.) *. (_B (-(n+1))) };
  *)
  compute_round n (x +. y) (xp + yp)

(*__     _____   ____    ____        _         _                  _   
  \ \   / /_ _| |___ \  / ___| _   _| |__  ___| |_ _ __ __ _  ___| |_ 
   \ \ / / | |    __) | \___ \| | | | '_ \/ __| __| '__/ _` |/ __| __|
    \ V /  | | _ / __/ _ ___) | |_| | |_) \__ \ |_| | | (_| | (__| |_ 
     \_/  |___(_)_____(_)____/ \__,_|_.__/|___/\__|_|  \__,_|\___|\__|
*)



(*---------------------------------------------
    Question 15
  ---------------------------------------------*)

let compute_neg (n: int) (ghost x: real) (xp: int)
  requires { framing x xp n }
  ensures  { framing (-. x) result n }
= - xp


(*---------------------------------------------
    Question 16
  ---------------------------------------------*)

let compute_sub (n: int) (ghost x: real) (xp: int) (ghost y: real) (yp: int)
  requires { framing x xp (n+1) }
  requires { framing y yp (n+1) }
  ensures { framing (x -. y) result n }
= 
  compute_add n x xp (-. y) (compute_neg (n+1) y yp)


(*__     _____   _____  ____                              _             
  \ \   / /_ _| |___ / / ___|___  _ ____   _____ _ __ ___(_) ___  _ __  
   \ \ / / | |    |_ \| |   / _ \| '_ \ \ / / _ \ '__/ __| |/ _ \| '_ \ 
    \ V /  | | _ ___) | |__| (_) | | | \ V /  __/ |  \__ \ | (_) | | | |
     \_/  |___(_)____(_)____\___/|_| |_|\_/ \___|_|  |___/_|\___/|_| |_|
*)

let compute_cst (n: int) (x : int) : int
  ensures { framing (from_int x) result n } =
  if n = 0 then
    x
  else if n < 0 then
  begin
    let ghost res = shift_right x (2*(-n)) in
    (* prove left *)
    assert { (from_int res -. 1.) *. _B (-n) <. from_int x 
      by (ED.div x (power 4 (-n))) * (power 4 (-n)) <= x 
      (* On part d'une inégalité de la division euclidienne *)
      so (res - 1) * (power 4 (-n)) < x 
      (* Puis on passe à une inégalité stricte en rajoutant le "-1" *)
      so from_int ((res - 1) * (power 4 (-n))) <. from_int x 
      (* On passe aux réels pour aider les solveurs *)
      so from_int ((res - 1)) *. from_int ((power 4 (-n))) <. from_int x };
    
    (* Prove right *)
    assert { from_int x <. (from_int res +. 1.) *. _B (-n)
      by x = (ED.div x (power 4 (-n))) * (power 4 (-n)) + (ED.mod x (power 4 (-n)))
      (* On part de l'égalité de base sur la division euclidienne *)
      so (ED.mod x (power 4 (-n))) < abs (power 4 (-n)) = (power 4 (-n))
      (* Et de l'inégalité sur le modulo *)
      (* Unable to prove the formula above without the "abs" function *) 
      so x < (ED.div x (power 4 (-n))) * (power 4 (-n)) + (power 4 (-n))
      (* On applique l'inégalité dans l'égalité *)
      so x < (ED.div x (power 4 (-n)) + 1) * (power 4 (-n))
      (* On factortise par "power 4 (-n)" *)
      so from_int x <. from_int ((ED.div x (power 4 (-n)) + 1) * (power 4 (-n))) };
      (* On passe aux réels pour aider les solveurs *)
    assert { framing (from_int x) res n };
    shift_right x (2*(-n))
  end
  else
  begin
    assert { framing (from_int x) ( x * (power 4 n) ) n };  
    shift_left x (2*n)
  end

(*---------------------------------------------
    Question 17
  ---------------------------------------------*)

let lemma sqrt_floor (n: int) : unit
  requires { n >= 1 }
  ensures { ceil (sqrt (from_int (n+1))) - 1 
            <= floor (sqrt (from_int n)) 
            <= floor (sqrt (from_int(n-1))) + 1 }
= 
  (* Prove left *) 
  assert { from_int n <=. (from_int n) +. 2. *. sqrt( from_int (n - 1)) }; 
  assert { sqrt ( from_int(n-1)) +. 1. = sqrt  ((from_int n) +. 2. *. sqrt( from_int (n - 1)))
    by (sqrt ( from_int(n-1)) +. 1. ) *. (sqrt ( from_int(n-1)) +. 1.) 
       = ((from_int n) +. 2. *. sqrt( from_int (n - 1))) };
  assert { sqrt (from_int n) <=. sqrt ( from_int(n-1)) +. 1. };
  
  (* Prove right *)
  let ghost z0 = floor (sqrt (from_int n)) in
  assert { z0 >= 1 };
  assert { (z0 + 1) * (z0 +1) >= n + 1
    by (from_int z0 +. 1.) *. (from_int z0 +. 1.) 
        = sqr (from_int z0) +. 2. *. (from_int z0) +. 1.
    so sqrt (from_int n) -. (from_int z0) <. 1.
    so sqr (from_int z0) +. 2. *. (from_int z0) +. 1.
      >=. sqr ( (sqrt (from_int n)) -. 1. ) +. 2. *. (from_int z0) +. 1.
      = (from_int n) +. 2. -. 2. *. (sqrt (from_int n) -. (from_int z0))
      >. (from_int n) +. 2. -. 2.     
    so (z0 + 1) * (z0+1) > n };
  assert { sqrt (from_int (n + 1)) <=. from_int z0 +. 1. 
    by from_int ((z0 + 1) * (z0 + 1)) 
      = ((from_int z0) +. 1. ) *. ((from_int z0) +. 1. ) 
      >=. from_int ( n + 1 ) };
  ()

(*---------------------------------------------
    Question 18
  ---------------------------------------------*)

let compute_sqrt (n: int) (ghost x : real) (xp : int)
  requires { 0. <=. x }
  requires { framing x xp (2*n) }
  ensures { framing (sqrt x) result n } 
=
  if xp <= 0 then
  begin
    assert { framing (sqrt x) 0 n };
    0
  end
  else
    let ghost res = isqrt xp in
    assert { res = floor (sqrt (from_int xp)) };
    let ghost _ = question9 (x -. 1.) (-n) in
    assert { (sqrt ( x -. 1.)) *. (_B (-n))
      = sqrt ( (x -. -1.) *. (_B (-2*n)))
      <. sqrt (from_int xp)
      <. sqrt ( (x +. -1.) *. (_B (-2*n)))
      =  (sqrt ( x +. 1.)) *. (_B (-n)) 
      };
    assert { sqrt (x -. 1.) <. sqrt x };
    assert { (sqrt (x -. 1.) +. 1. ) <. sqrt x +. 1. };
    assert { framing (sqrt x) res n };
    isqrt xp






type term = 
  | Cst int
  | Add term term
  | Neg term
  | Sub term term
  | Sqrt term

let rec ghost function interp (t: term) : real =
  match t with
  | Cst i -> from_int i
  | Add t t' -> (interp t) +. (interp t')
  | Neg t -> 0. -. (interp t)
  | Sub t t' -> (interp t) -. (interp t')
  | Sqrt t -> sqrt (interp t)
  end

predicate wf_term (t: term) =
  match t with
  | Cst _ -> True
  | Add t t' -> (wf_term t) /\ (wf_term t')
  | Neg t -> (wf_term t)
  | Sub t t' -> (wf_term t) /\ (wf_term t')
  | Sqrt t -> (wf_term t) /\ (interp t >=. 0.)
  end

let rec compute (t: term) (n: int) : int
  requires { wf_term t }
  variant { t }
  ensures { framing (interp t) result n }
=
  match t with
  | Cst i -> 
      compute_cst n i
  | Add t1 t2 -> 
    let x1 = compute t1 (n+1) in
    let x2 = compute t2 (n+1) in
      compute_add n (interp t1) x1 (interp t2) x2
  | Neg t' -> 
    let x = compute t' n in
      compute_neg n (interp t') x
  | Sub t1 t2 ->
    let x1 = compute t1 (n+1) in
    let x2 = compute t2 (n+1) in
      compute_sub n (interp t1) x1 (interp t2) x2
  | Sqrt t' -> 
    let x = compute t' (2*n) in
      compute_sqrt n (interp t') x
  end
 
let lemma div_a_b_plus_1 (a: int) (b: int) : unit
  requires { a > 0 }
  requires { b > 0 }
  requires { ED.div a  b < b }
  ensures { ED.div a (b+1) = 
      if (ED.mod a b) < (ED.div a b) then 
        (ED.div a b) -1
      else
        (ED.div a b) }
= 
  let ghost y = ED.div a b in
  let ghost z = ED.mod a b in
  assert { a = y * b + z };
  assert { a = y * (b+1) + z - y};
  if y < z then
  begin
    assert { b > z - y >= 0 };
    let ghost _ = euclid_uniq a (b+1) y in
    assert { ED.div a (b+1) = y
      by a = y * b + z
      so a = y * (b + 1) + ( z - y) };
    ()
  end
  else
    (* assert { a = *)
    ()
             