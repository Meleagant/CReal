\documentclass[9pt,a4paper,twocolumn]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[greek,french]{babel}
\usepackage{hyperref}
\usepackage{amssymb}
\usepackage{verbatim}
\usepackage{xargs}

% \usepackage[pagewise]{lineno}
% \linenumbers

%\usepackage{setspace}
%\setstretch{1,5}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%    Pour les graphes %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{tikz,pgf}
\usetikzlibrary{arrows,automata} % Pour les graphe
\tikzset{every picture/.style={execute at begin picture={%
   \shorthandoff{:;!?};}
}}
\usepackage{pgf-umlsd}
\usepackage{minted}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%     Pour les figures    %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{epsfig}
%\usepackage{slashbox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%    Pour les théorêmes et tout...    %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{amsmath,amsthm}
\theoremstyle{definition}
\newtheorem{theorem}{Th\'eor\`eme}
\newtheorem{hypo}{Hypoth\`ese}
\newtheorem{definition}{Définition}
\newtheorem{lemma}{Lemme}
\newtheorem{hyp}{Hypoth\`ese}
\usepackage{stmaryrd}
\usepackage{mathtools}

\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

% use biblatex for bib
%\usepackage{biblatex}
%\addbibresource{biblio.bib}

\usepackage{multirow}

\usepackage{caption}
\captionsetup[table]{name=Tableau}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%    Pour une belle mise en page     %%%%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Grosses marges par défaut
%\usepackage{geometry}
% Marges extérieures pour l'annotation
\usepackage[left=1.25cm, right=1.25cm,top = 2.25cm, bottom = 2.25cm]{geometry}
% Pas de marges pour la version finale
%\usepackage[left=1.5cm, right=3.5cm,top = 2.5cm, bottom = 2.5cm]{geometry}
% TODO : penser à remettr correctement les marges
%\setlength{\hoffset}{-18pt}
% \setlength{\oddsidemargin}{0cm}   % Marge gauche sur pages impaires
% \setlength{\evensidemargin}{4 cm}  % Marge gauche sur pages paires
% \setlength{\marginparwidth}{4cm} % Largeur de note dans la marge
% \setlength{\textwidth}{452pt}     % Largeur de la zone de texte (17cm)
% \setlength{\voffset}{-18pt}       % Bon pour DOS
% \setlength{\marginparsep}{4cm}    % SÃ©paration de la marge
% \setlength{\topmargin}{0pt}       % Pas de marge en haut
% \setlength{\headheight}{13pt}     % Haut de page
% \setlength{\headsep}{10pt}        % Entre le haut de page et le texte
% \setlength{\footskip}{27pt}       % Bas de page + sÃ©paration
% \setlength{\textheight}{650pt}    % Hauteur de la zone de texte (25cm)
%


\usepackage{fancyhdr}
\pagestyle{fancy}
\usepackage{lastpage}
\renewcommand{\headrulewidth}{1pt}
\fancyhead[L]{CReal}
\fancyhead[R]{J. \textsc{Giet}}
\fancyfoot[C]{\thepage/\pageref{LastPage}}

%\renewcommand*\rmdefault{ppl}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%          Raccourcis usuels         %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%   Symboles mathÃ©matiques %%%%%%
\newcommand{\K}{\ensuremath\mathbb{K}}
\newcommand{\N}{\ensuremath\mathbb{N}}
\newcommand{\Z}{\ensuremath\mathbb{Z}}
\newcommand{\D}{\ensuremath\mathbb{D}}
\newcommand{\Q}{\ensuremath\mathbb{Q}}
\newcommand{\R}{\ensuremath\mathbb{R}}
\newcommand{\M}{\ensuremath\mathbb{M}}
\renewcommand{\L}{\ensuremath\mathbb{L}}
\newcommand{\U}{\ensuremath\mathbb{U}}
\newcommand{\C}{\ensuremath\mathbb{C}}
\newcommand{\E}{\ensuremath\mathbb{E}}
\newcommand{\V}{\ensuremath\mathbb{V}}
\newcommand{\B}{\texttt{\_B}}
\renewcommand{\O}{\ensuremath\mathcal{O}}
\renewcommand{\P}{\mathcal{P}}
\newcommand{\A}{\mathcal{A}}
\renewcommand{\a}{{\scriptscriptstyle\mathcal{A}}}
\renewcommand{\S}{\mathcal{S}}

%%%%% DEs raccourcis propres au projet
\newcommand{\reduc}{\textbf{reduc}}
\newcommand{\trans}{\textbf{trans}}
\newcommand{\guard}{\textbf{guard}}
\newcommand{\defi}{\text{def.}}

%%%%%  ParenthÃ¨ses & autres %%%%%%
\newcommand{\po}{\left(} % grande parenthÃ¨se ouvrante
\newcommand{\pf}{\right)} % grande parenthÃ¨se fermante
\newcommand{\ao}{\left\lbrace}
\newcommand{\af}{\right\rbrace}
\newcommand{\dco}{\llbracket}
\newcommand{\dcf}{\rrbracket}

%%%% Raccourcis usuels   %%%%
\newcommand{\ie}{\textit{i.e. }}
\newcommand{\eg}{\textit{e.g. }}
\newcommand{\cf}{\textit{cf. }}
\newcommand{\ssi}{\text{ si et seulement si }}
\newcommand{\si}{\text{ si }}

%%%%  Pour le module math   %%%%
\newcommand{\et}{\text{~et }}
\newcommand{\ou}{\text{~ou }}
\newcommand{\car}{\text{~car }}
\newcommand{\avec}{\text{~avec }}

%%%%  FlÃªches et autres  %%%%
\renewcommand{\le}{\leqslant}
\renewcommand{\ge}{\geqslant}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\renewcommand{\emptyset}{\varnothing}
\newcommand{\la}{\leftarrow}
\newcommand{\xla}{\xleftarrow}
\newcommand{\ra}{\rightarrow}
\newcommand{\xra}{\xrightarrow}

\usepackage{xcolor}
\newcommand{\TODO}{{\color{red}\textbf{\textit{TODO}}}}



%%%% Pour la méta
% \newcommand{\TODO}{\textgreek{\textbf{\color{red}TODO}}}
% \newcommand{\Rq}{\textbf{\color{blue}Remarque(s)}}

\usemintedstyle{emacs}
\renewcommand{\listingscaption}{Code}
\renewcommand{\listoflistingscaption}{Table des fragments de code}
% Définition de l'envirronement Code pour le OCaml
\newenvironment{code}[1][ocaml]{%
\newgeometry{textwidth = 0.8\textwidth}
\VerbatimEnvironment\begin{minted}[
%linenos,
frame=lines,
framesep=2mm,
fontsize=\footnotesize,
mathescape,
autogobble]{#1}%
}{%
\end{minted}
\restoregeometry
}
% \usepackage{tcolorbox}
% \usepackage{etoolbox}
% \BeforeBeginEnvironment{code}{\begin{tcolorbox}}%
% \AfterEndEnvironment{code}{\end{tcolorbox}}%


\usepackage[nottoc, notlof, notlot]{tocbibind}

% Pour les numéros de section en chiffre romain
\renewcommand{\thesection}{\Roman{section}}

\title{CReal: Arithmétique en précision arbitraire}   % Mettre le titre iÃ§i!!
\author{Josselin \textsc{Giet}}  % Renseigner le nom de l'auteur
%\date{}    % Par dÃ©faut ,on ne met pas de date
%\date{}
% SOn commente cette ligne en dessus pour savoir les dates de compilation

\begin{document}
\maketitle

\section*{Introduction}

Le projet a été traité dans son intégralité à l'exception des questions 23
(fonction \texttt{inv\_simple\_simple}) et 27 (terminaison de la fonction
\texttt{compute}).
J'ai utilisé deux solveurs : Alt-Ergo 2.2.0 et Z3 4.4.1. et dans la majorité des
cas, les preuves se font en moins d'une minute.
Afin de ménager mon ordinateur, j'ai préféré faire des tactiques \texttt{split}
ainsi que de nombreux \texttt{assert}.
De plus, après certains \texttt{why3 replay}, des buts n'étaient plus prouvés
(les solveurs dépassaient le temps imparti).
J'ai donc du rajouter des \texttt{assert} qui peuvent paraître redondants.
Par exemple dans les cas où il fait \textit{déplacer} les \texttt{from\_int}.





\tableofcontents
\listoflistings

\section{Axioms}


J'ai ajouté de la manière suivante un axiome pour disposer de la stricte
croissance de la fonction \texttt{log}
\begin{listing}
\begin{code}[ocaml]
axiom log_incr:
  forall x y: real. 0.0 <. x <. y -> (log x) <. (log y)
\end{code}
\caption{Axiome de la stricte croissance de \texttt{log}}
\end{listing}

%----------------------------------------------------------------------------
% II. function on integers
%----------------------------------------------------------------------------
\section{Functions on integers}

% I.1. power2
\textbf{II.1}
J'utilise une version itérative « naïve » de l'exponentielle pour
calculer $2^n$. Au début de la fonction je crée une référence sur la valeur
\texttt{l} donnée en argument ainsi qu'une référence sur le futur résultat
\texttt{res}, initialisée à 0. Dans une boucle \texttt{while}, je décrémente
cette référence et je multiplie \texttt{res} par $2$.

Dans cette boucle \texttt{while}, le variant est la référence \texttt{!x},
et les invariants sont \texttt{!res * power 2 !x = power 2 l}, pour prouver
le bon résultat et \texttt{!x >= 0} afin d'inférer à la fin de la boucle que
\texttt{!x=0}.


J'ai aussi rajouter un \texttt{ensures} de plus sur le résultat :
il est strictement positif et donc un invariant sur la référence du futur
résultat : \texttt{!res > 0}.
Cela a été nécessaire dans la question \textbf{II.4} afin de montrer que
$2^\ell > 0$

\begin{listing}
\begin{code}[ocaml]
  let power2 (l:int) : int
    requires { 0 <= l }
    ensures { result = power 2 l }
    ensures { result > 0 }
\end{code}
  \label{lst:power2}
  \caption{Contrat de la fonction \texttt{power2}}
\end{listing}

\textbf{II.2}
Une fois donnée la définition de la fonction \texttt{power2}, la définition de
\texttt{shift\_left} est immédiate.

\begin{listing}[H]
\begin{code}[ocaml]
  let shift_left (z: int) (l:int) : int
    requires { 0 <= l }
    ensures { result = z * (power 2 l) }
    = z * power2 l
\end{code}
\label{lst:shiftleft}
\caption{Code de la fonction \texttt{shift\_left}}
\end{listing}

\textbf{II.3}
Pour la division euclidienne \texttt{ediv\_mod}, j'ai dû faire une disjonction
de cas selon le signe du dividende \texttt{x}.
Chaque cas se fait de manière itérative : on maintient un compteur \texttt{d}
et un accumulateur \texttt{r} pour le reste.
Ainsi dans chaque boucle on maintient l'invariant : \texttt{x = !d * y + !r}.

Pour le premier cas (\texttt{x >= 0}) on retranche \texttt{y} à \texttt{!r}
à chaque passage dans la boucle et on incrémente \texttt{!d} et ce tanty que
\texttt{!r >= y}.
Le variant est donc \texttt{!r - y}.
Outre l'invariant commun aux deux cas, on maintient l'invariant \texttt{!r >= 0}
pour déterminer après le passage dans la boucle que \texttt{ y > !r >= 0}.

Dans l'autre cas (\texttt{x < 0}) on ajoute \texttt{y} à \texttt{!r} à chaque
passage dans la boucle et on décrémente \texttt{!d} et ce tant que \texttt{!r < 0}.
De même que dans le premier cas on maintient un invariant entre \texttt{!r} et
\texttt{y} : \texttt{!r < y}, pour montrer après le passage dans la boucle que
\texttt{ y > !r >= 0}.

\begin{listing}
\begin{code}[ocaml]
let ediv_mod (x:int) (y:int) : (int, int)
  requires { 0 < y }
  ensures { let d,r = result in
     d = ED.div x y /\ r = ED.mod x y }
\end{code}
\label{lst:edivmod}
\caption{Contrat de la fonction \texttt{ediv\_mod}}
\end{listing}

\textbf{II.4}
De même que pour la question I.2, la fonction \texttt{shift\_right} est définie
sans problèmes en utilisant la division euclidienne de la fonction
précédente.

\begin{listing}
\begin{code}[ocaml]
let shift_right (z: int) (l:int) : int
  requires { 0 <= l }
  ensures { result = ED.div z (power 2 l) }
=
  let p2l = power2 l in
  assert { p2l > 0 };
  let d, _ = ediv_mod z p2l in
    d
\end{code}
\label{lst:shiftright}
\caption{Code de la fonction \texttt{shift\_right}}
\end{listing}

\textbf{II.5}
Pour la fonction \texttt{isqrt}, j'ai fait une version itérative proche de
celle dans l'exercice du cours. Je crée une référence sur le futur résultat
\texttt{res}, initialisée à 0, que j'incrémente tant que
$
(\texttt{!res} +1)^2 \leq \texttt{n}
$.
La variant de la boucle est donc \texttt{n - !res * ! res}.
Les invariants sont \texttt{!res >= 0} et \texttt{ !res * !res <= n}.
Je conclue la fonction en montrant l'inégalité qui est la définition de la
fonction \texttt{floor}:
$$
(\texttt{!res} =)
\sqrt{\texttt{!res}^2} \leq \sqrt{\texttt{n}}
  < \sqrt{(\texttt{!res}+1)^2}
  (=\texttt{!res}+1)
$$

\begin{listing}
\begin{code}[ocaml]
let function isqrt (n: int) : int
  requires {0 <= n}
  ensures { result = floor (sqrt (from_int n)) }
\end{code}
\label{lst:isqrt}
\caption{Contrat de la fonction \texttt{isqrt}}
\end{listing}

\section{Difficulty of Non-linear Arithmetic on Reals}

\textbf{III.6-12}
Pour ces questions, j'ai écrit les lemmes sous forme de
\textit{function lemmas} et les solveurs ont prouvé facilement ces lemmes.
La seule \textit{difficulté} rencontrée fût dans la question \textbf{III.9},
où j'ai dû rajouter un \texttt{assert} dans le corps de la fonction pour
montrer que $\sqrt{\B(2n)} = \B(n)$.

\textbf{III.13}

Dans \TODO il y a deux deux définitions équivalentes de \texttt{framing} :
\begin{align}
\forall x \in \R, p, n \in \Z,\  \nonumber
	& \texttt{framing}\ x\ p\ n \\
\Longleftrightarrow \ \
	& \left( p-1 \right) \cdot 4^{-n}
		< x <
		\left( p+1 \right) \cdot 4^{-n}
	\label{eq:fram-1} \\
\Longleftrightarrow \ \
	& |x-p\cdot 4^{-n}| < 4^{-n}
	\label{eq:fram-2}
\end{align}

La définition \ref{eq:fram-1} est préférable à \ref{eq:fram-2} car elle fait
intervenir moins de fonctions non-linéaires.
En effet, il n'y a pas de de valeurs absolues dans la première définition.

\section{Computational Real}

\subsection{Addition}


\textbf{IV.14}
Pour la fonction \texttt{round\_z\_over\_4}, j'ai prouvé les deux inégalités
séparément. Pour l'inégalité de gauche, la preuve se  base sur le fait que :
$$
	(z-2)\B(-1)
	= \frac{z-2}{4}
	< \floor*{ \frac{z - 2}{4} + 1 }
	= \floor*{ \frac{z+2}{4} }
$$
et pour celle de droite :
$$
\floor*{ \frac{z + 2}{4} }
	\leq \frac{z+2}{4}
	= (z + 2)\B(-1)
$$

\begin{listing}
\begin{code}[ocaml]
let round_z_over_4 (z: int)
  ensures { ((from_int z) -. 2.) *. (_B (-1))
            <. from_int result
            <=. ((from_int z) +. 2.) *. (_B (-1)) }
\end{code}
\label{lst:roundzover4}
\caption{Contrat de la fonction \texttt{round\_z\_over\_4}}
\end{listing}

Pour la fonction \texttt{compute\_round}, j'ai aussi prouvé séparément les deux
inégalités.
Celle de gauche se montre en remarquant que :

$$
\floor*{\frac{\texttt{zp} + 2}{4}} - 1
\leq \frac{\texttt{zp} -2}{4}
$$
et donc :
\begin{align*}
\left(\floor*{\frac{\texttt{zp} + 2}{4}} - 1\right) \cdot \B(-n)
  &\leq \frac{\texttt{zp} -2}{4} \cdot \B(-n)\\
  &= (\texttt{zp} -2)\cdot \B(-(n+1))\\
  &< z
\end{align*}

Pour l'inégalité de droite, on a plus simplement :
\begin{align*}
z &\leq \texttt{zp}\cdot\B(-(n+1)) \\
  &\leq (\texttt{zp}+2)\cdot\B(-(n+1)) \\
  &= \frac{\texttt{zp}+2}{4}\cdot\B(-n)\\
  &< \left(\floor*{\frac{\texttt{zp} + 2}{4}} + 1\right) \cdot \B(-n)\\
\end{align*}

\begin{listing}
\begin{code}[ocaml]
let compute_round (n: int) (ghost z: real) (zp: int)
  requires {  ((from_int zp) -. 2.) *. (_B (-(n+1)))
            <. z
            <=. ((from_int zp) +. 2.) *. (_B (-(n+1))) }
  ensures { framing z result n }
\end{code}
\label{lst:roundzover4}
\caption{Contrat de la fonction \texttt{compute\_round}}
\end{listing}


Enfin, pour la fonction \texttt{compute\_add}, les preuves ont été automatiquement
inférées par les solveurs.

\begin{listing}
\begin{code}[ocaml]
let compute_add (n: int) (ghost x: real)
  (xp: int) (ghost y: real) (yp: int)
  requires { framing x xp (n+1) }
  requires { framing y yp (n+1) }
  ensures { framing (x+.y) result n }
= compute_round n (x +. y) (xp + yp)
\end{code}
\label{lst:computeadd}
\caption{Contrat de la fonction \texttt{compute\_add}}
\end{listing}

\subsection{Substraction}

\textbf{IV.15}
De même, la fonction \texttt{compute\_neg} est automatiquement prouvée par les solveurs.

\begin{listing}
\begin{code}[ocaml]
  let compute_neg (n: int) (ghost x: real) (xp: int)
    requires { framing x xp n }
    ensures  { framing (-. x) result n }
  = - xp
\end{code}
\caption{Code de la fonction \texttt{compute\_neg}}
\end{listing}

\textbf{IV.16}
En utilisant les fonctions \texttt{compute\_add} et \texttt{compute\_neg}
on obtient naturellement le code de la fonction \texttt{compute\_sub}.
De même que pour la fonction \texttt{Compute\_add}, il faut une hypothèse de
\texttt{framing} à l'ordre $n+1$ pour avoir une précision à l'ordre $n$ sur le
résultat

\begin{listing}
\begin{code}[ocaml]
   let compute_sub (n: int) (ghost x: real)
     (xp: int) (ghost y: real) (yp: int)
     requires { framing x xp (n+1) }
     requires { framing y yp (n+1) }
     ensures { framing (x -. y) result n }
   =
     compute_add n x xp (-. y) (compute_neg (n+1) y yp)
\end{code}
\caption{Code de la fonction \texttt{compute\_sub}}
\end{listing}

\subsection{Conversion}

Bien que n'étant pas une question à proprement parler, la preuve de la fonction
\texttt{compute\_cst} a nécessité des \texttt{asserts} pour guider les solveurs
dans le cas \texttt{n < 0}. Les autres cas (\texttt{n = 0} et \texttt{n > 0})
ont été prouvés sans problèmes par les solveurs.
Encore une fois, la preuve s'est faite en prouvant séparément les inégalités.

Pour celle de gauche :

\begin{align*}
   &\floor*{\frac{\texttt{x}}{4^{-\texttt{n}}}}\cdot 4^{-\texttt{n}}
      \leq x\\
\Rightarrow
   &\left(\floor*{\frac{\texttt{x}}{4^{-\texttt{n}}}}-1\right)\cdot 4^{-\texttt{n}}
      < x\\
\end{align*}

Et pour celle de droite :

\begin{align*}
   &\floor*{\frac{\texttt{x}}{4^{-\texttt{n}}}}\cdot 4^{-\texttt{n}}
      + \underbrace{\texttt{x} \mod 4^{-\texttt{n}}}_{<4^{-\texttt{n}}} \\
   &< \floor*{\frac{\texttt{x}}{4^{-\texttt{n}}}}\cdot 4^{-\texttt{n}}
      + 4^{-\texttt{n}} \\
   & = \left(\floor*{\frac{\texttt{x}}{4^{-\texttt{n}}}}+1\right)\cdot 4^{-\texttt{n}}
\end{align*}

\subsection{Square Root}


\textbf{IV.17}
J'ai prouvé la double inégalité
\begin{equation}
\ceil*{\sqrt{\texttt{n}+1}} -1
\leq \floor*{\sqrt{\texttt{n}}}
\leq \floor*{\sqrt{\texttt{n}-1}}+1
\label{eq:sqrt}
\end{equation}

en séparant les deux inégalités.

Celle de gauche se montre assez facilement :

\begin{align*}
   &\texttt{n} \leq \texttt{n} +2\cdot\sqrt{\texttt{n}-1}
      =\left(\sqrt{\texttt{n}-1}+1\right)^2\\
\Rightarrow
    &\sqrt{ \texttt{n} } \leq \sqrt{\texttt{n}-1}+1 \\
 \Rightarrow
        &\floor*{\sqrt{ \texttt{n} }} \leq \sqrt{\texttt{n}-1}+1 \\
\end{align*}

Pour celle de droite,

\begin{align*}
   \left(\floor*{\sqrt{n}}+1 \right)^2
   &=\left(\floor*{\sqrt{n}}\right)^2 + 2\floor*{\sqrt{n}} +1
\\   &\geq \left(\sqrt{n} -1 \right)^2 + 2\floor*{\sqrt{n}} +1
\\   &= n + 2 -2
      \underbrace{\left(\sqrt{ n }- \floor*{\sqrt{ n }}\right)}_{< 1}
\\   &> n + 2 -2
\\   &= n
\end{align*}

Donc :
\begin{align*}
   &\left(\floor*{\sqrt{n}}+1 \right)^2 > n
\\   \Rightarrow
   &\left(\floor*{\sqrt{n}}+1 \right)^2 \geq n+1
\end{align*}
Car les termes de chaque coté sont des entiers.

En appliquant la fonction racine carrée de chaque côté de l'inégalité,
on obtient le résultat attendu.
\begin{listing}
\begin{code}[ocaml]
   let lemma sqrt_floor (n: int) : unit
     requires { n >= 1 }
     ensures { ceil (sqrt (from_int (n+1))) - 1
               <= floor (sqrt (from_int n))
               <= floor (sqrt (from_int(n-1))) + 1 }
\end{code}
\caption{Contrat du lemme \texttt{sqrt\_floor}}
\end{listing}

\textbf{IV.18}
La preuve de la fonction \texttt{compute\_sqrt}, repose directement sur le lemme
précédent.

Pour le cas \texttt{xp}$\leq 0$, la preuve est trouvée immédiatement par le
solveur.

Le second cas est prouvée de la manière suivante :

\begin{align*}
     &\left( \floor*{\sqrt{ \texttt{xp} }}-1 \right)\B(-n)
\\ &\leq \left( \floor*{\sqrt{ \texttt{xp}-1 }} \right)\B(-n)
  & \text{En utilisant \ref{eq:sqrt}}
\\ &\leq \left( \sqrt{\texttt{xp}-1} \right)\B(-n)
  & \text{Car }\floor{\bullet} \leq \bullet
\\ &=  \sqrt{\left(\texttt{xp}-1 \right)\B(-2n)}
\\ &< \sqrt{ x }
   & \text{Par hypothèse }
\\ &< \sqrt{\left(\texttt{xp}+1 \right)\B(-2n)}
\\ &\leq \left( \sqrt{\texttt{xp}+1} \right)\B(-n)
\\ &\leq \left( \ceil*{\sqrt{ \texttt{xp}+1 }} \right)\B(-n)
   & \text{Car }\ceil*{\bullet} \geq \bullet
\\ &\leq \left( \floor*{\sqrt{ \texttt{xp} }}+1 \right)\B(-n)
& \text{En utilisant \ref{eq:sqrt}}
\end{align*}

\begin{listing}
\begin{code}[ocaml]
   let compute_sqrt (n: int) (ghost x : real) (xp : int)
     requires { 0. <=. x }
     requires { framing x xp (2*n) }
     ensures { framing (sqrt x) result n }
\end{code}
\caption{Contrat de la fonction \texttt{compute\_sqrt}}
\end{listing}


\subsection{Compute}

\textbf{IV.19-20}
La fonction \texttt{interp} et le prédicat \texttt{wf\_term}
s'écrivent immédiatement par induction :


\begin{listing}
\begin{code}[ocaml]
let rec ghost function interp (t: term) : real =
  match t with
  | Cst i -> from_int i
  | Add t t' -> (interp t) +. (interp t')
  | Neg t -> 0. -. (interp t)
  | Sub t t' -> (interp t) -. (interp t')
  | Sqrt t -> sqrt (interp t)
  end
\end{code}
\caption{Code de la fonction \texttt{interp}}
\end{listing}

\begin{listing}
\begin{code}[ocaml]
predicate wf_term (t: term) =
  match t with
  | Cst _ -> True
  | Add t t' -> (wf_term t) /\ (wf_term t')
  | Neg t -> (wf_term t)
  | Sub t t' -> (wf_term t) /\ (wf_term t')
  | Sqrt t -> (wf_term t) /\ (interp t >=. 0.)
  end
\end{code}
\caption{Code du prédicat \texttt{wf\_term}}
\end{listing}

\textbf{IV.21}
De même la fonction \texttt{compute} s'écrit facilement de manière récursive.
Chaque appel récursif se fait sur un sous-terme strictement plus petit
en utilisant une nouvelle valeur pour la précision pour avoir une bonne
précision pour le résultat.

La preuve ne pose pas de problème une fois qu'on a appliqué la tactique
\texttt{destruct\_alg t}


\begin{listing}
\begin{code}[ocaml]
   let rec compute (t: term) (n: int) : int
     requires { wf_term t }
     variant { t }
     ensures { framing (interp t) result n }
\end{code}
\caption{Contrat de la fonction \texttt{compute}}
\end{listing}

\section{Division}

\textbf{V.22}
J'ai prouvé les deux lemmes séparément. Toutefois ils ont le même schéma de
preuve.
On part de l'égalité $a = (\texttt{ED.div}\ a\ b)*b+(\texttt{ED.mod}\ a\ b)$.
Puis on la modifie pour obtenir le la division selon $b\pm 1$, et on conclue en
appelant le lemme \texttt{euclid\_uniq}, car le «reste» est dans le bon
intervalle

Pour le premier lemme :

\begin{align*}
   a = d\cdot b+r = d(b+1) +r-d
\end{align*}

\begin{itemize}
   \item Si $r < d$ :
\begin{align*}
a   &= (d-1)(b+1) +
   \underbrace{r-d+1+b+1}_{b+1 > \bullet\geq 0}
\end{align*}
   \item Sinon $r \geq d$ d'où
\begin{align*}
a
   &= d(b+1) +
   \underbrace{r-d}_{\geq 0} \\
\end{align*}
\end{itemize}



\begin{listing}
\begin{code}[ocaml]
let lemma div_a_b_plus_1 (a: int) (b: int) : unit
  requires { a > 0 }
  requires { b > 0 }
  requires { ED.div a  b < b }
  ensures { ED.div a (b+1) =
    if (ED.mod a b) < (ED.div a b)
      then (ED.div a b) -1
      else (ED.div a b) }
\end{code}
\caption{Contrat du premier lemme}
\end{listing}

Pour le second lemme :

\begin{align*}
a = d\cdot b +r = d(b-1) +r +d
\end{align*}

\begin{itemize}
   \item Si $b-1-d \leq r$,
   \begin{align*}
      a = (d+1)(b-1) + r + d - b + 1
   \end{align*}
   \item Sinon,
   \begin{align*}
      a = d(b-1) + r + d
   \end{align*}
\end{itemize}

\begin{listing}
\begin{code}[ocaml]
   let lemma div_a_b_minus_1 (a: int) (b: int) : unit
     requires { a > 0 }
     requires { b > 1 }
     requires { ED.div a b < b - 1 }
     ensures { ED.div a (b-1) =
       if ED.mod a b >= b - 1 - (ED.div a b)
         then (ED.div a b) + 1
         else  ED.div a b
\end{code}
\caption{Contrat du second lemme}
\end{listing}

\textbf{V.23}
Pour la fonction \texttt{inv\_simple\_simple}, j'y arrive pas :( !

\textbf{V.24}
Pour la fonction \texttt{inv\_simple}, la pruve se fait en deux temps :
celle de la précondition pour l'appel à \texttt{inv\_simple\_simple}, puis celle
de la post-condition de la fonction.

Pour la précondition :

$$
(\texttt{p}-1)\B(-(n+1+2m)) < x < (\texttt{p}+1)\B(-(n+1+2m))
$$

En remarquant que $\B(-(n+1+2m)) = \B(-m)\B(-(n+1+m)) =
\frac{ \B(-(n+1+m)) }{ \B(m) }$, on a :

$$
(\texttt{p}-1)\B(-(n+1+m)) < x\B(m) < (\texttt{p}+1)\B(-(n+1+m))
$$

Pour la post-condition, on fait la preuve inverse.

\begin{listing}
\begin{code}[ocaml]
let inv_simple (ghost x: real) (p m n: int)
  requires{ 0 <= m}
  requires{ 0 <= n}
  requires{ _B (-m) <. x}
  requires { framing x p (n+1+2*m) }
  ensures { framing (inv x) result n }
\end{code}
\caption{Contrat de la fonction \texttt{inv\_simple}}
\end{listing}

\textbf{V.25}
Pour cette question, j'ai réécris le type \texttt{term}, la fonction
\texttt{interp} et le prédicat \texttt{wf\_term}, pour prendre en compte le cas
de la fonction inverse.


\begin{listing}
\begin{code}[ocaml]
type term2 =
  | Cst2 int
  | Add2 term2 term2
  | Neg2 term2
  | Sub2 term2 term2
  | Sqrt2 term2
  | Inv2 term2


let rec ghost function interp2 (t: term2) : real =
  match t with
  | Cst2 i -> from_int i
  | Add2 t t' -> (interp2 t) +. (interp2 t')
  | Neg2 t -> 0. -. (interp2 t)
  | Sub2 t t' -> (interp2 t) -. (interp2 t')
  | Sqrt2 t -> sqrt (interp2 t)
  | Inv2 t -> Real.inv (interp2 t)
  end

predicate wf_term2 (t: term2) =
  match t with
  | Cst2 _ -> True
  | Add2 t t' -> (wf_term2 t) /\ (wf_term2 t')
  | Neg2 t -> (wf_term2 t)
  | Sub2 t t' -> (wf_term2 t) /\ (wf_term2 t')
  | Sqrt2 t -> (wf_term2 t) /\ (interp2 t >=. 0.)
  | Inv2 t -> (wf_term2 t) /\ (interp2 t <> 0.)
  end
\end{code}
\caption{Code pour l'extension du type \texttt{term}}
\end{listing}

\textbf{V.26}
De même que pour la première fonction \texttt{compute}, celle-ci se prouve
facilement en utilisant le tactique \texttt{destruct\_alg t}.
Le seul cas un tant soit peu complexe est dans le cas de l'inversion d'un nombre
négatif. J'ai donc rajouté un lemme \texttt{frame\_opp}.

Pour la fonction \texttt{msd}, le seul cas non trivial est le cas \texttt{c}$<1$.
Il seul traite en utilisant l'hypothèse d'encadrement.
On a, $c < -1$ or comme $c\in\Z$, $c -1 \leq -1$ d'où :
$\texttt{interp}(\texttt{t}) < (c+1)\B(-n) \leq \B(-n)$.


\begin{listing}
\begin{code}[ocaml]
let lemma frame_opp (x: real) (p n: int) : unit
  requires { framing x p n}
  ensures { framing (-. x) (- p) n }
\end{code}
\caption{Contrat du lemme \texttt{frame\_opp}}
\end{listing}

\begin{listing}
\begin{code}[ocaml]
let rec compute2 (t: term2) (n: int) : int
  requires { wf_term2 t }
  requires { 0 <= n }
  variant { t }
  ensures { framing (interp2 t) result n }
\end{code}
\caption{Contrat de la fonction \texttt{compute2}}
\end{listing}

\begin{listing}
\begin{code}[ocaml]
with msd (t: term2) (n: int) (c: int) : (int, bool)
  requires { 0 <= n }
  requires { wf_term2 t }
  requires { interp2 t <> 0. }
  requires { framing (interp2 t) c n }
  variant { (t, -n) }
  ensures { let m, sgn = result in
    0 <= m /\
    if sgn then  _B(-m) <. interp2 t
           else interp2 t <. -. _B(-m) }
\end{code}
\caption{Contrat de la fonction \texttt{msd}}
\end{listing}

\textbf{V.27}
Maman, j'y arrive pas !

\section*{Conclusion}



%\newpage
%\tableofcontents
%\listoflistings
%\listoffigures
%\listoftables
%\newpage


\end{document}
