\documentclass[9pt,a4paper,twocolumn]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[greek,french]{babel}
\usepackage{hyperref}
\usepackage{amssymb}
\usepackage{verbatim}
\usepackage{xargs}

% \usepackage[pagewise]{lineno}
% \linenumbers

%\usepackage{setspace}
%\setstretch{1,5}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%    Pour les graphes %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{tikz,pgf}
\usetikzlibrary{arrows,automata} % Pour les graphe
\tikzset{every picture/.style={execute at begin picture={%
   \shorthandoff{:;!?};}
}}
\usepackage{pgf-umlsd}
\usepackage{minted}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%     Pour les figures    %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{epsfig}
%\usepackage{slashbox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%    Pour les théorêmes et tout...    %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{amsmath,amsthm}
\theoremstyle{definition}
\newtheorem{theorem}{Th\'eor\`eme}
\newtheorem{hypo}{Hypoth\`ese}
\newtheorem{definition}{Définition}
\newtheorem{lemma}{Lemme}
\newtheorem{hyp}{Hypoth\`ese}
\usepackage{stmaryrd}
\usepackage{mathtools}

\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

% use biblatex for bib
%\usepackage{biblatex}
%\addbibresource{biblio.bib}

\usepackage{multirow}

\usepackage{caption}
\captionsetup[table]{name=Tableau}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%    Pour une belle mise en page     %%%%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Grosses marges par défaut
%\usepackage{geometry}
% Marges extérieures pour l'annotation
\usepackage[left=1.25cm, right=1.25cm,top = 2.25cm, bottom = 2.25cm]{geometry}
% Pas de marges pour la version finale
%\usepackage[left=1.5cm, right=3.5cm,top = 2.5cm, bottom = 2.5cm]{geometry}
% TODO : penser à remettr correctement les marges
%\setlength{\hoffset}{-18pt}
% \setlength{\oddsidemargin}{0cm}   % Marge gauche sur pages impaires
% \setlength{\evensidemargin}{4 cm}  % Marge gauche sur pages paires
% \setlength{\marginparwidth}{4cm} % Largeur de note dans la marge
% \setlength{\textwidth}{452pt}     % Largeur de la zone de texte (17cm)
% \setlength{\voffset}{-18pt}       % Bon pour DOS
% \setlength{\marginparsep}{4cm}    % SÃ©paration de la marge
% \setlength{\topmargin}{0pt}       % Pas de marge en haut
% \setlength{\headheight}{13pt}     % Haut de page
% \setlength{\headsep}{10pt}        % Entre le haut de page et le texte
% \setlength{\footskip}{27pt}       % Bas de page + sÃ©paration
% \setlength{\textheight}{650pt}    % Hauteur de la zone de texte (25cm)
%


\usepackage{fancyhdr}
\pagestyle{fancy}
\usepackage{lastpage}
\renewcommand{\headrulewidth}{1pt}
\fancyhead[L]{CReal}
\fancyhead[R]{J. \textsc{Giet}}
\fancyfoot[C]{\thepage/\pageref{LastPage}}

%\renewcommand*\rmdefault{ppl}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%          Raccourcis usuels         %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%   Symboles mathÃ©matiques %%%%%%
\newcommand{\K}{\ensuremath\mathbb{K}}
\newcommand{\N}{\ensuremath\mathbb{N}}
\newcommand{\Z}{\ensuremath\mathbb{Z}}
\newcommand{\D}{\ensuremath\mathbb{D}}
\newcommand{\Q}{\ensuremath\mathbb{Q}}
\newcommand{\R}{\ensuremath\mathbb{R}}
\newcommand{\M}{\ensuremath\mathbb{M}}
\renewcommand{\L}{\ensuremath\mathbb{L}}
\newcommand{\U}{\ensuremath\mathbb{U}}
\newcommand{\C}{\ensuremath\mathbb{C}}
\newcommand{\E}{\ensuremath\mathbb{E}}
\newcommand{\V}{\ensuremath\mathbb{V}}
\newcommand{\B}{\texttt{\_B}}
\renewcommand{\O}{\ensuremath\mathcal{O}}
\renewcommand{\P}{\mathcal{P}}
\newcommand{\A}{\mathcal{A}}
\renewcommand{\a}{{\scriptscriptstyle\mathcal{A}}}
\renewcommand{\S}{\mathcal{S}}

%%%%% DEs raccourcis propres au projet
\newcommand{\reduc}{\textbf{reduc}}
\newcommand{\trans}{\textbf{trans}}
\newcommand{\guard}{\textbf{guard}}
\newcommand{\defi}{\text{def.}}

%%%%%  ParenthÃ¨ses & autres %%%%%%
\newcommand{\po}{\left(} % grande parenthÃ¨se ouvrante
\newcommand{\pf}{\right)} % grande parenthÃ¨se fermante
\newcommand{\ao}{\left\lbrace}
\newcommand{\af}{\right\rbrace}
\newcommand{\dco}{\llbracket}
\newcommand{\dcf}{\rrbracket}

%%%% Raccourcis usuels   %%%%
\newcommand{\ie}{\textit{i.e. }}
\newcommand{\eg}{\textit{e.g. }}
\newcommand{\cf}{\textit{cf. }}
\newcommand{\ssi}{\text{ si et seulement si }}
\newcommand{\si}{\text{ si }}

%%%%  Pour le module math   %%%%
\newcommand{\et}{\text{~et }}
\newcommand{\ou}{\text{~ou }}
\newcommand{\car}{\text{~car }}
\newcommand{\avec}{\text{~avec }}

%%%%  FlÃªches et autres  %%%%
\renewcommand{\le}{\leqslant}
\renewcommand{\ge}{\geqslant}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\renewcommand{\emptyset}{\varnothing}
\newcommand{\la}{\leftarrow}
\newcommand{\xla}{\xleftarrow}
\newcommand{\ra}{\rightarrow}
\newcommand{\xra}{\xrightarrow}

\usepackage{xcolor}
\newcommand{\TODO}{{\color{red}\textbf{\textit{TODO}}}}



%%%% Pour la méta
% \newcommand{\TODO}{\textgreek{\textbf{\color{red}TODO}}}
% \newcommand{\Rq}{\textbf{\color{blue}Remarque(s)}}

\usemintedstyle{emacs}
\renewcommand{\listingscaption}{Code}
\renewcommand{\listoflistingscaption}{Table des fragments de code}
% Définition de l'envirronement Code pour le OCaml
\newenvironment{code}[1][ocaml]{%
\newgeometry{textwidth = 0.8\textwidth}
\VerbatimEnvironment\begin{minted}[
%linenos,
frame=lines,
framesep=2mm,
fontsize=\footnotesize,
mathescape,
autogobble]{#1}%
}{%
\end{minted}
\restoregeometry
}

\usepackage[nottoc, notlof, notlot]{tocbibind}

% Pour les numéros de section en chiffre romain
\renewcommand{\thesection}{\Roman{section}}

\title{CReal: Arithmétique en précision arbitraire}   % Mettre le titre iÃ§i!!
\author{Josselin \textsc{Giet}}  % Renseigner le nom de l'auteur
%\date{}    % Par dÃ©faut ,on ne met pas de date
%\date{}
% SOn commente cette ligne en dessus pour savoir les dates de compilation

\begin{document}
\maketitle

\section*{Introduction}
\TODO
\tableofcontents
\listoflistings

\section{Axioms}


J'ai ajouté de la manière suivante un axiome pour disposer de la stricte
croissance de la fonction \texttt{log}
\begin{listing}
\begin{code}[ocaml]
axiom log_incr:
  forall x y: real. 0.0 <. x <. y -> (log x) <. (log y)
\end{code}
\caption{Axiome de la stricte croissance de \texttt{log}}
\end{listing}

%----------------------------------------------------------------------------
% II. function on integers
%----------------------------------------------------------------------------
\section{Functions on integers}

% I.1. power2
\textbf{II.1}
J'utilise une version itérative « naïve » de l'exponentielle pour
calculer $2^n$. Au début de la fonction je crée une référence sur la valeur
\texttt{l} donnée en argument ainsi qu'une référence sur le futur résultat
\texttt{res}, initialisée à 0. Dans une boucle \texttt{while}, je décrémente
cette référence et je multiplie \texttt{res} par $2$.

Dans cette boucle \texttt{while}, le variant est la référence \texttt{!x},
et les invariants sont \texttt{!res * power 2 !x = power 2 l}, pour prouver
le bon résultat et \texttt{!x >= 0} afin d'inférer à la fin de la boucle que
\texttt{!x=0}.


J'ai aussi rajouter un \texttt{ensures} de plus sur le résultat :
il est strictement positif et donc un invariant sur la référence du futur
résultat : \texttt{!res > 0}.
Cela a été nécessaire dans la question \textbf{II.4} afin de montrer que
$2^\ell > 0$

\begin{listing}
\begin{code}[ocaml]
  let power2 (l:int) : int
    requires { 0 <= l }
    ensures { result = power 2 l }
    ensures { result > 0 }
\end{code}
  \label{lst:power2}
  \caption{Contrat de la fonction \texttt{power2}}
\end{listing}

\textbf{II.2}
Une fois donnée la définition de la fonction \texttt{power2}, la défnition de
\texttt{shift\_left} est immédiate.

\begin{listing}[H]
\begin{code}[ocaml]
  let shift_left (z: int) (l:int) : int
    requires { 0 <= l }
    ensures { result = z * (power 2 l) }
    = z * power2 l
\end{code}
\label{lst:shiftleft}
\caption{Code de la fonction \texttt{shift\_left}}
\end{listing}

\textbf{II.3}
Pour la division euclidienne \texttt{ediv\_mod}, j'ai dû faire une disjonction
de cas selon le signe du dividende \texttt{x}.
Chaque cas se fait de manière itérative : on maintient un compteur \texttt{d}
et un accumulateur \texttt{r} pour le reste.
Ainsi dans chaque boucle on maintient l'invariant : \texttt{x = !d * y + !r}.

Pour le premier cas (\texttt{x >= 0}) on retranche \texttt{y} à \texttt{!r}
à chaque passage dans la boucle et on incrémente \texttt{!d} et ce tanty que
\texttt{!r >= y}.
Le variant est donc \texttt{!r - y}.
Outre l'invariant commun aux deux cas, on maintient l'invariant \texttt{!r >= 0}
pour déterminer après le passage dans la boucle que \texttt{ y > !r >= 0}.

Dans l'autre cas (\texttt{x < 0}) on ajoute \texttt{y} à \texttt{!r} à chaque
passage dans la boucle et on décrémente \texttt{!d} et ce tant que \texttt{!r < 0}.
De même que dans le premier cas on maintient un invariant entre \texttt{!r} et
\texttt{y} : \texttt{!r < y}, pour montrer après le passage dans la boucle que
\texttt{ y > !r >= 0}.

\begin{listing}
\begin{code}[ocaml]
let ediv_mod (x:int) (y:int) : (int, int)
  requires { 0 < y }
  ensures { let d,r = result in
     d = ED.div x y /\ r = ED.mod x y }
\end{code}
\label{lst:edivmod}
\caption{Contrat de la fonction \texttt{ediv\_mod}}
\end{listing}

\textbf{II.4}
De même que pour la question I.2, la fonction \texttt{shift\_right} est définie
sans problèmes en utilisant la divsion euclidienne de la fonction
précédente.

\begin{listing}
\begin{code}[ocaml]
let shift_right (z: int) (l:int) : int
  requires { 0 <= l }
  ensures { result = ED.div z (power 2 l) }
=
  let p2l = power2 l in
  assert { p2l > 0 };
  let d, _ = ediv_mod z p2l in
    d
\end{code}
\label{lst:shiftright}
\caption{Code de la fonction \texttt{shift\_right}}
\end{listing}

\textbf{II.5}
Pour la fonction \texttt{isqrt}, j'ai fait une version itérative proche de
celle dans l'exercice du cours. Je crée une référence sur le futur résultat
\texttt{res}, initialisée à 0, que j'incrémente tant que
$
(\texttt{!res} +1)^2 \leq \texttt{n}
$.
La variant de la boucle est donc \texttt{n - !res * ! res}.
Les invariants sont \texttt{!res >= 0} et \texttt{ !res * !res <= n}.
Je conclue la fonction en montrant l'inégalité qui est la définition de la
fonction \texttt{floor}:
$$
(\texttt{!res} =)
\sqrt{\texttt{!res}^2} \leq \sqrt{\texttt{n}}
  < \sqrt{(\texttt{!res}+1)^2}
  (=\texttt{!res}+1)
$$

\begin{listing}
\begin{code}[ocaml]
let function isqrt (n: int) : int
  requires {0 <= n}
  ensures { result = floor (sqrt (from_int n)) }
\end{code}
\label{lst:isqrt}
\caption{Contrat de la fonction \texttt{isqrt}}
\end{listing}

\section{Difficulty of Non-linear Arithmetic on Reals}

\textbf{III.6-12}
Pour ces questions, j'ai écrit les lemmes sous forme de
\textit{function lemmas} et les solveurs ont prouvé facilement ces lemmes.
La seule \textit{difficulté} rencontrée fût dans la question \textbf{III.9},
où j'ai dû rajouter un \texttt{assert} dans le corps de la fonction pour
montrer que $\sqrt{\B(2n)} = \B(n)$.

\textbf{III.13}

Dans \TODO il y a deux deux définitions equvalentes de \texttt{framing} :
\begin{align}
\forall x \in \R, p, n \in \Z,\  \nonumber
	& \texttt{framing}\ x\ p\ n \\
\Longleftrightarrow \ \
	& \left( p-1 \right) \cdot 4^{-n}
		< x <
		\left( p+1 \right) \cdot 4^{-n}
	\label{eq:fram-1} \\
\Longleftrightarrow \ \
	& |x-p\cdot 4^{-n}| < 4^{-n}
	\label{eq:fram-2}
\end{align}

La définition \ref{eq:fram-1} est préférable à \ref{eq:fram-2} car elle fait
intervenir moins de fonctions non-linéaires.
En effet, il n'y a pas de de valeurs absolues dans la première définition.

\section{Computational Real}

\subsection{Addition}


\textbf{IV.14}
Pour la fonction \texttt{round\_z\_over\_4}, j'ai prouvé les deux inégalités
séparément. Pour l'inégalité de gauche, la preuve se  base sur le fait que :
$$
	(z-2)\B(-1)
	= \frac{z-2}{4}
	< \floor*{ \frac{z - 2}{4} + 1 }
	= \floor*{ \frac{z+2}{4} }
$$
et pour celle de droite :
$$
\floor*{ \frac{z + 2}{4} }
	\leq \frac{z+2}{4}
	= (z + 2)\B(-1)
$$

\begin{listing}
\begin{code}[ocaml]
let round_z_over_4 (z: int)
  ensures { ((from_int z) -. 2.) *. (_B (-1))
            <. from_int result
            <=. ((from_int z) +. 2.) *. (_B (-1)) }
\end{code}
\label{lst:roundzover4}
\caption{Contrat de la fonction \texttt{round\_z\_over\_4}}
\end{listing}

Pour la fonction \texttt{compute\_round}, j'ai aussi prouvé séparément les deux
inégalités.
Celle de gauche se montre en remarquant que :

$$
\floor*{\frac{\texttt{zp} + 2}{4}} - 1
\leq \frac{\texttt{zp} -2}{4}
$$
et donc :
\begin{align*}
\left(\floor*{\frac{\texttt{zp} + 2}{4}} - 1\right) \cdot \B(-n)
  &\leq \frac{\texttt{zp} -2}{4} \cdot \B(-n)\\
  &= (\texttt{zp} -2)\cdot \B(-(n+1))\\
  &< z
\end{align*}

Pour l'inégalité de droite, on a plus simplement :
\begin{align*}
z &\leq \texttt{zp}\cdot\B(-(n+1)) \\
  &\leq (\texttt{zp}+2)\cdot\B(-(n+1)) \\
  &= \frac{\texttt{zp}+2}{4}\cdot\B(-n)\\
  &< \left(\floor*{\frac{\texttt{zp} + 2}{4}} + 1\right) \cdot \B(-n)\\
\end{align*}

\begin{listing}
\begin{code}[ocaml]
let compute_round (n: int) (ghost z: real) (zp: int)
  requires {  ((from_int zp) -. 2.) *. (_B (-(n+1)))
            <. z
            <=. ((from_int zp) +. 2.) *. (_B (-(n+1))) }
  ensures { framing z result n }
\end{code}
\label{lst:roundzover4}
\caption{Contrat de la fonction \texttt{compute\_round}}
\end{listing}


Enfin, pour la fonction \texttt{compute\_add}, les preuves ont été automatiquement
inférées par les solveurs.

\begin{listing}
\begin{code}[ocaml]
let compute_add (n: int) (ghost x: real)
  (xp: int) (ghost y: real) (yp: int)
  requires { framing x xp (n+1) }
  requires { framing y yp (n+1) }
  ensures { framing (x+.y) result n }
= compute_round n (x +. y) (xp + yp)
\end{code}
\label{lst:computeadd}
\caption{Contrat de la fonction \texttt{compute\_add}}
\end{listing}

\subsection{Substraction}

\textbf{IV.15}
De même, la fonction \texttt{compute\_neg} est automatiquement prouvée par les solveurs.

\begin{listing}
\begin{code}[ocaml]
  let compute_neg (n: int) (ghost x: real) (xp: int)
    requires { framing x xp n }
    ensures  { framing (-. x) result n }
  = - xp
\end{code}
\caption{Code de la fonction \texttt{compute\_neg}}
\end{listing}

\textbf{IV.16}
En utilisant les fonctions \texttt{compute\_add} et \texttt{compute\_neg}
on obtient naturellement le code de la fonction \texttt{compute\_sub}.
De même que pour la fonction \texttt{Compute\_add}, il faut une hypothèse de
\texttt{framing} à l'ordre $n+1$ pour avoir une précision à l'ordre $n$ sur le
résultat

\begin{listing}
\begin{code}[ocaml]
   let compute_sub (n: int) (ghost x: real)
     (xp: int) (ghost y: real) (yp: int)
     requires { framing x xp (n+1) }
     requires { framing y yp (n+1) }
     ensures { framing (x -. y) result n }
   =
     compute_add n x xp (-. y) (compute_neg (n+1) y yp)
\end{code}
\caption{Code de la fonction \texttt{compute\_sub}}
\end{listing}

\subsection{Conversion}

Bien que n'étant pas une fonction à proprement parler, la preuve de la fonction
\texttt{compute\_cst} a nécessité des \texttt{asserts} pour guider les solveurs
dans le cas \texttt{n < 0}. Les uatres cas (\texttt{n = 0} et \texttt{n > 0})
ont été prouvés sans problèmes par les solveurs.
Encore une fois, la preuve s'est faite en prouvant séparément les inégalités.

Pour celle de gauche :

\begin{align*}
   &\floor*{\frac{\texttt{x}}{4^{-\texttt{n}}}}\cdot 4^{-\texttt{n}}
      \leq x\\
\Rightarrow
   &\left(\floor*{\frac{\texttt{x}}{4^{-\texttt{n}}}}-1\right)\cdot 4^{-\texttt{n}}
      < x\\
\end{align*}

Et pour celle de droite :

\begin{align*}
   &\floor*{\frac{\texttt{x}}{4^{-\texttt{n}}}}\cdot 4^{-\texttt{n}}
      + \underbrace{\texttt{x} \mod 4^{-\texttt{n}}}_{<4^{-\texttt{n}}} \\
   &< \floor*{\frac{\texttt{x}}{4^{-\texttt{n}}}}\cdot 4^{-\texttt{n}}
      + 4^{-\texttt{n}} \\
   & = \left(\floor*{\frac{\texttt{x}}{4^{-\texttt{n}}}}+1\right)\cdot 4^{-\texttt{n}}
\end{align*}

\textbf{IV.17}
J'ai prouvé la double inégalité
$
\ceil*{\sqrt{\texttt{n}+1}} -1
\leq \floor*{\sqrt{\texttt{n}}}
\leq \floor*{\sqrt{\texttt{n}-1}}+1
$
en séparant les deux inégalités.

Celle de gauche se montre assez facilement :

\begin{align*}
   &\texttt{n} \leq \texttt{n} +2\cdot\sqrt{\texttt{n}-1}
      =\left(\sqrt{\texttt{n}-1}+1\right)^2\\
\Rightarrow
    &\sqrt{ \texttt{n} } \leq \sqrt{\texttt{n}-1}+1 \\
 \Rightarrow
        &\floor*{\sqrt{ \texttt{n} }} \leq \sqrt{\texttt{n}-1}+1 \\
\end{align*}

Pour celle de droite,

\begin{listing}
\begin{code}[ocaml]
   let lemma sqrt_floor (n: int) : unit
     requires { n >= 1 }
     ensures { ceil (sqrt (from_int (n+1))) - 1
               <= floor (sqrt (from_int n))
               <= floor (sqrt (from_int(n-1))) + 1 }
\end{code}
\caption{contrat du lemme \texttt{sqrt\_floor}}
\end{listing}


























%\newpage
%\tableofcontents
%\listoflistings
%\listoffigures
%\listoftables
%\newpage


\end{document}
